{
    "version": "https://jsonfeed.org/version/1",
    "title": "boch.dev",
    "home_page_url": "http://localhost:4000/",
    "feed_url": "http://localhost:4000/feed.json",
    "description": "Dull notes about Ruby and JS.",
    "icon": "http://localhost:4000/apple-touch-icon.png",
    "favicon": "http://localhost:4000/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "Patryk",
        "url": "boch.dev",
        "avatar": null
    },
    
"items": [
    
        {
            "id": "http://localhost:4000/2022/08/14/race-on-condiitons-in-rails",
            "title": "Race (on) condition(s) in Rails",
            "summary": "How to solve race condition problems in rails",
            "content_text": "Some argue that Ruby on Rails applications cannot scale. That is a common response given by candidates in job interviews when asked about the disadvantages of the framework. I don’t want to choose a side. I might respond, “it depends” - as always. Anyhow, if you want to prepare your app for receiving numerous requests at once, you need to consider the race condition issue which is liable to cause us troubles.I don’t want to delve into the definition of “race condition” as I’m sure my readers understand what it is because it is fundamental to software engineering. I’d like to concentrate on ways to get rid of this. If you’re unfamiliar and you want to discover more about the term’s origins, go here. Anyways, one line will adequately describe the problem.  When your app allows multiple requests to interact with the same records, and one request overrides changes made by another without taking them into account.For instance, if a large number of requests modify the same record at the same time in multi-users scenario.As my final point in this introduction, I want to emphasize that a database must ensure integrity of data, particularly when performing concurrent operations. Integrity introduces the ACID-compliant idea of “locking” into the picture. Because of this, both optimistic and pessimistic locking are considered as means of addressing race condition issues.Good old optimistic lockingOptimistic locking is when the version attribute maintained in a database column is taken into account. It’s the implicit technique of dodging the issue IMO. If we intend to use it, the special lock_version column needs to be added and Active Record, which is Rails’ default component, takes care of minimizing data conflicts.add_column :table_name, :lock_version, :integerEach time a record is updated, the lock_version entity is increased and the locking features make sure that records will only allow the last one stored to throw a StaleObjectError if there is a parallel update of any kind. Then, we can attempt updating the data again.Rails are adaptable; if you want to use your own table with a name that differs from lock_version you can do so by specyfing in your model:self.locking_column = :custom_lock_versionWhy is this type of dealing with race condition regarded as optimistic? Because it is assumed that database conflicts occur less frequently. Optimistic locking performs by simply comparing the “version” column value. As a result, it does not represent a true database lock.Good old pessimistic lockingPessimistic locking, on the other hand, is a technique that counts on more frequent database conflicts. Since it offers an exclusive lock on the record, it is regarded as more explicit. When a single request modifies a record, it locks it until a transaction is completed. For this purpose a built-in methods with_lock and #lock! are used. Both operate similarly to each other. The main difference is that the #lock! needs to be used within an Active Record’s transaction since it is unlocked again when the surrounding transaction is finished; sadly, using it outside the transaction block is ineffective. The with_lock method initiates a database transaction by itself. Anyways, all methods prevent others from reading or writing a record until the transaction is completed.See the with_lock API reference.Summing up good old techniquesBoth locking methods are regarded as useful; however, the cost of a transaction retry must be considered when selecting a suitable locking scheme. It is determined by app requirements and business logic. Let’s summarize these two approaches briefly.            Optimistic locking      Pessimistic locking                  Locks a record once changes are comitted to db      Locks record once it is edited              Considers data conflicts less frequently      Considers data conflicts more frequently              Needs a version number stored in a db column for locking a record      Needs an invocation of with_lock or #lock! methods for locking a record              Allows a conflict to occur and may retry or throw an error      Blocks conflicts until a record is unlocked (a transaction is done)              Is used once a cost of retry is low      Is used once a cost of retry is high      Rather than locking a record for entire transactions by pessimistic way, I’d take the optimistic approach and that’s what I recommend. As alwyas, at the end, it depends on the use case that may force the pessimistic approach.There are more methods besides optimism and pessimism to stay away from race conditions. Since more libraries need to be installed, let’s quickly go over the details of two additional, more particular approaches.Advisory lockingAnother useful technique is the advisory locking. It doesn’t lock records but guarantees that no two processes operate another process at the same time (by adding mutexes). In order to do so you’d need to extend an app with with_advisory_lock gem. See official docs for details.Background processing and queuesI’m sure that all readers know what background processing is as it’s fundamental. In ruby apps Sidekiq is used frequently to handle background jobs that may alter db records. An extension to Sidekiq - SidekiqUniqueJobs adds extra constraints and prevents from race conditions there. The configuration is pretty straight forward since only an extra middleware must be configured. See official docs for details.It may be difficult to create consistent systems without problems with data integrity so knowing strategies that let us avoid race conditions are desirable. Of course, there are more locking strategies, but I’ve only shown those that I find most useful in my day-to-day work as a developer.",
            "content_html": "<p>Some argue that Ruby on Rails applications cannot scale. That is a common response given by candidates in job interviews when asked about the disadvantages of the framework. I don’t want to choose a side. I might respond, “it depends” - as always. Anyhow, if you want to prepare your app for receiving numerous requests at once, you need to consider the <em>race condition</em> issue which is liable to cause us troubles.</p><p>I don’t want to delve into the definition of “race condition” as I’m sure my readers understand what it is because it is fundamental to software engineering. I’d like to concentrate on ways to get rid of this. If you’re unfamiliar and you want to discover more about the term’s origins, go <a href=\"https://devopedia.org/race-condition-software\">here</a>. Anyways, one line will adequately describe the problem.</p><blockquote>  <p>When your app allows multiple requests to interact with the same records, and one request overrides changes made by another without taking them into account.</p></blockquote><p>For instance, if a large number of requests modify the same record at the same time in multi-users scenario.</p><p>As my final point in this introduction, I want to emphasize that a database must ensure integrity of data, particularly when performing concurrent operations. Integrity introduces the ACID-compliant idea of “locking” into the picture. Because of this, both optimistic and pessimistic locking are considered as means of addressing race condition issues.</p><h2 id=\"good-old-optimistic-locking\">Good old <em>optimistic locking</em></h2><p>Optimistic locking is when the version attribute maintained in a database column is taken into account. It’s the implicit technique of dodging the issue IMO. If we intend to use it, the special <em>lock_version</em> column needs to be added and Active Record, which is Rails’ default component, takes care of minimizing data conflicts.</p><div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">add_column</span> <span class=\"ss\">:table_name</span><span class=\"p\">,</span> <span class=\"ss\">:lock_version</span><span class=\"p\">,</span> <span class=\"ss\">:integer</span></code></pre></div></div><p>Each time a record is updated, the <code class=\"language-plaintext highlighter-rouge\">lock_version</code> entity is increased and the locking features make sure that records will only allow the last one stored to throw a <code class=\"language-plaintext highlighter-rouge\">StaleObjectError</code> if there is a parallel update of any kind. Then, we can attempt updating the data again.</p><script src=\"https://gist.github.com/patrykboch/99296a4395b362ed3dbd279adedf02b1.js\"></script><p>Rails are adaptable; if you want to use your own table with a name that differs from <em>lock_version</em> you can do so by specyfing in your model:</p><div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">self</span><span class=\"p\">.</span><span class=\"nf\">locking_column</span> <span class=\"o\">=</span> <span class=\"ss\">:custom_lock_version</span></code></pre></div></div><p>Why is this type of dealing with race condition regarded as optimistic? Because it is assumed that database conflicts occur less frequently. Optimistic locking performs by simply comparing the “version” column value. As a result, it does not represent a true database lock.</p><h2 id=\"good-old-pessimistic-locking\">Good old <em>pessimistic locking</em></h2><p>Pessimistic locking, on the other hand, is a technique that counts on more frequent database conflicts. Since it offers an exclusive lock on the record, it is regarded as more explicit. When a single request modifies a record, it locks it until a transaction is completed. For this purpose a built-in methods <code class=\"language-plaintext highlighter-rouge\">with_lock</code> and <code class=\"language-plaintext highlighter-rouge\">#lock!</code> are used. Both operate similarly to each other. The main difference is that the <code class=\"language-plaintext highlighter-rouge\">#lock!</code> needs to be used within an Active Record’s transaction since it is unlocked again when the surrounding transaction is finished; sadly, using it outside the transaction block is ineffective. The <code class=\"language-plaintext highlighter-rouge\">with_lock</code> method initiates a database transaction by itself. Anyways, all methods prevent others from reading or writing a record until the transaction is completed.</p><script src=\"https://gist.github.com/patrykboch/0ec6ae5943fc43331771a34ac1df9fe2.js\"></script><p><a href=\"https://api.rubyonrails.org/classes/ActiveRecord/Locking/Pessimistic.html\">See the <code class=\"language-plaintext highlighter-rouge\">with_lock</code> API reference</a>.</p><h2 id=\"summing-up-good-old-techniques\">Summing up good old techniques</h2><p>Both locking methods are regarded as useful; however, the cost of a transaction retry must be considered when selecting a suitable locking scheme. It is determined by app requirements and business logic. Let’s summarize these two approaches briefly.<br /><br /></p><table>  <thead>    <tr>      <th>Optimistic locking</th>      <th>Pessimistic locking</th>    </tr>  </thead>  <tbody>    <tr>      <td>Locks a record once changes are comitted to db</td>      <td>Locks record once it is edited</td>    </tr>    <tr>      <td>Considers data conflicts less frequently</td>      <td>Considers data conflicts more frequently</td>    </tr>    <tr>      <td>Needs a version number stored in a db column for locking a record</td>      <td>Needs an invocation of <code class=\"language-plaintext highlighter-rouge\">with_lock</code> or <code class=\"language-plaintext highlighter-rouge\">#lock!</code> methods for locking a record</td>    </tr>    <tr>      <td>Allows a conflict to occur and may retry or throw an error</td>      <td>Blocks conflicts until a record is unlocked (a transaction is done)</td>    </tr>    <tr>      <td>Is used once a cost of retry is low</td>      <td>Is used once a cost of retry is high</td>    </tr>  </tbody></table><p><br />Rather than locking a record for entire transactions by pessimistic way, I’d take the optimistic approach and that’s what I recommend. As alwyas, at the end, it depends on the use case that may force the pessimistic approach.</p><p>There are more methods besides optimism and pessimism to stay away from race conditions. Since more libraries need to be installed, let’s quickly go over the details of two additional, more particular approaches.</p><h2 id=\"advisory-locking\">Advisory locking</h2><p>Another useful technique is the advisory locking. It doesn’t lock records but guarantees that no two processes operate another process at the same time (by adding mutexes). In order to do so you’d need to extend an app with <a href=\"https://github.com/ClosureTree/with_advisory_lock\"><em>with_advisory_lock</em></a> gem. See official docs for details.</p><h2 id=\"background-processing-and-queues\">Background processing and queues</h2><p>I’m sure that all readers know what background processing is as it’s fundamental. In ruby apps Sidekiq is used frequently to handle background jobs that may alter db records. An extension to Sidekiq - <a href=\"https://github.com/mhenrixon/sidekiq-unique-jobs\">SidekiqUniqueJobs</a> adds extra constraints and prevents from race conditions there. The configuration is pretty straight forward since only an extra middleware must be configured. See official docs for details.</p><p>It may be difficult to create consistent systems without problems with data integrity so knowing strategies that let us avoid race conditions are desirable. Of course, there are more locking strategies, but I’ve only shown those that I find most useful in my day-to-day work as a developer.</p>",
            "url": "http://localhost:4000/2022/08/14/race-on-condiitons-in-rails",
            
            
            
            "tags": ["ruby","rails","race condition","optimistic lock","pesimistic lock"],
            
            "date_published": "2022-08-14T00:00:00+02:00",
            "date_modified": "2022-08-14T00:00:00+02:00",
            
                "author":  {
                "name": "Patryk",
                "url": "boch.dev",
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://localhost:4000/2022/08/12/proxy-as-the-way-of-metaprogramming-in-js",
            "title": "Proxy as the way of metaprogramming in JS",
            "summary": "How to use Proxy es6 object in JS for metaprogramming",
            "content_text": "Important note: Described Proxy object is something different than one of the OOP patterns.I’ve seen several odd JS characteristics ever since I started using it on a daily basis. One of these irritates me — undefined rather than a code execution error when attempting to access properties that don’t exist. In this regard, JS behaves somewhat differently from my experience with Ruby:and a Ruby equivalent:The error throw is produced by Ruby, but JS returns undefined. Imagine working on a large JS project and a simple property typo results in an app being broken because undefined was used instead of the key not found throw. You would not know why or where this happened because undefined may appear throughout many different places (debugging undefined may take a long time). Fortunately, the built-in Proxies objects provided by the ES6+ standard provide a solution to the concern.Since the release of ES6, JS is known as fully reflective programming language as the Reflection API has been advanced.  Reflection is the ability of a computer program to examine, introspect, and modify its own structure and behavior at runtime.That implies that a program can execute on each of the three levels mentioned. Please be aware that ES5 has provided the potential of reflective introspection and self-modification - Object.keys() for introspection or Object#delete for self-modification - also all Object.* methods are taken as reflective for metaprogramming, but neither they nor other ES5 features support the third level of reflection - behavioral level which is the reason for the introduction of proxies in ES6 that alter built-in language operations.  The Proxy object is used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc). (official docs)Using proxies is a way for virtualizing objects eg. POJOs. Virtualized object peeks the same as a given object, and any operation on a given one directs to an already created virtualized by a proxy object. By virtualization, we can take control of standard methods default behavior by intercepting invocations and re-defining them.Nothing special above, virtualization of the object and the property lookup without invoking any operations(see: no-op forwarding). When you add a property to an object, the same property is added to the proxy object. Although it is a symlink, proxies are designed to intercept low-level operations on the target object.Error instead of undefined…when accessing non-existent property with the get trap.Let’s solve the issue that is raised at the beginning of the post. How can the default behavior, which terminates in undefined be changed to an error caused by code execution like in Ruby or Python? Let’s start by describing the default behavior using a proxy object:Let’s change the default behaviour:I passed the trap the following three arguments: 1) the target object for the proxy is denoted the trapTarget 2) the key - the property and 3) the receiver - the proxy reference. The js object Reflect, which describes the default behavior of js. Please note there is a Reflect technique for each proxy trap.To recap, operations can be intercepted using a handler and a proxy trap, which is a function that is always supplied as the second proxy argument and is in charge of the operation.  I’ve shown two branches on the diagram: the default behavior and the proxy’s interception of the default behavior.On the most fundamental level, default reflection yields undefined. The same outcome is also possible with a proxy.The second branch - Proxy intercepts default behaviour by get trap in the handler and raises an error in the code example if property doesn’t exist.Note: get trap is one of many others traps - see all available traps for the Proxy.Building two-way data binding using ProxyMoving on let’s dive into a more complex thing. If you’re familiar with AngularJS or VueJS you’re probably into two-way data binding concept as it’s the main philosophy of these frameworks (see AngularJS docs or VueJs example of v-model)  Two-way-data binding links the state with the view. If the state changes the view is updated and if the view changes the state will be updated.Using Proxy is the way to go if you want to create your own two-way data binding-based js framework. Our view can be connected to application state through a proxy. Consider the following illustration:see live exampleThe state and the view are now bound. The view alters as the state does. First, I gave the DOM input elements a brand-new attribute called data-model. The key component of two-way data binding is the model, which connects input value and app state. After that, I created the straightforward state interface with two keys (name and hobby).It’s good to note that only keys that have been set in the interface can be modified in a proxy; otherwise, an error will be raised if eg. state.strangerKey = \"Hello\". The next step is to build a proxy that has a set trap in the handler; updateView is added between calls to the default engine set behavior, which means that each time the state is attempted to be changed, the input values in the view will also be altered. From a view to a state direction. Also listeners have been provided to the view that detect input value changes and trigger the state change. So registering listeners on DOM elements is crucial because only registered listeners can change the state via the onInputChange event handler.For now, the journey with Proxy wound up, I’ve presented the most common proxy traps - get and set but keep in mind that Proxy supports twelve more handlers which can be used for different purposes, especially in metaprogramming.PS. Metaprogramming rocks :).",
            "content_html": "<p>Important note: Described <em>Proxy</em> object is something different than one of the OOP patterns.</p><p>I’ve seen several odd JS characteristics ever since I started using it on a daily basis. One of these irritates me — <code class=\"language-plaintext highlighter-rouge\">undefined</code> rather than a code execution error when attempting to access properties that don’t exist. In this regard, JS behaves somewhat differently from my experience with Ruby:</p><script src=\"https://gist.github.com/patrykboch/48bf5dd1f626c2c889c8bfa43931dd51.js\"></script><p>and a Ruby equivalent:</p><script src=\"https://gist.github.com/patrykboch/c29bb0a5faacee9c1548c23eb4eff44b.js\"></script><p>The error throw is produced by Ruby, but JS returns <code class=\"language-plaintext highlighter-rouge\">undefined</code>. Imagine working on a large JS project and a simple property typo results in an app being broken because <code class=\"language-plaintext highlighter-rouge\">undefined</code> was used instead of the <em>key not found</em> throw. You would not know why or where this happened because <code class=\"language-plaintext highlighter-rouge\">undefined</code> may appear throughout many different places (debugging undefined may take a long time). Fortunately, the built-in Proxies objects provided by the ES6+ standard provide a solution to the concern.</p><p>Since the release of ES6, JS is known as fully reflective programming language as the <em>Reflection API</em> has been advanced.</p><blockquote>  <p>Reflection is the ability of a computer program to examine, introspect, and modify its own structure and behavior at runtime.</p></blockquote><p>That implies that a program can execute on each of the three levels mentioned. Please be aware that ES5 has provided the potential of reflective introspection and self-modification - <code class=\"language-plaintext highlighter-rouge\">Object.keys()</code> for introspection or <code class=\"language-plaintext highlighter-rouge\">Object#delete</code> for self-modification - also all <code class=\"language-plaintext highlighter-rouge\">Object.*</code> methods are taken as reflective for metaprogramming, but neither they nor other ES5 features support the third level of reflection - <em>behavioral level</em> which is the reason for the introduction of proxies in ES6 that alter built-in language operations.</p><blockquote>  <p>The Proxy object is used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc). <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Meta_programming\">(official docs)</a></p></blockquote><p>Using proxies is a way for virtualizing objects eg. POJOs. Virtualized object peeks the same as a given object, and any operation on a given one directs to an already created virtualized by a proxy object. By virtualization, we can take control of standard methods default behavior by intercepting invocations and re-defining them.</p><script src=\"https://gist.github.com/patrykboch/cf189feaad1e574d01194ff9d9a04a31.js\"></script><p>Nothing special above, virtualization of the object and the property lookup without invoking any operations(see: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#No-op_forwarding_proxy\">no-op forwarding</a>). When you add a property to an object, the same property is added to the proxy object. Although it is a symlink, proxies are designed to intercept low-level operations on the target object.</p><h2 id=\"error-instead-of-undefined\">Error instead of undefined</h2><p><em>…when accessing non-existent property with the <code class=\"language-plaintext highlighter-rouge\">get</code> trap.</em></p><p>Let’s solve the issue that is raised at the beginning of the post. How can the default behavior, which terminates in <code class=\"language-plaintext highlighter-rouge\">undefined</code> be changed to an error caused by code execution like in Ruby or Python? Let’s start by describing the default behavior using a proxy object:</p><script src=\"https://gist.github.com/patrykboch/d069e35aaf76b55c5f75ffe6a35eef34.js\"></script><p>Let’s change the default behaviour:</p><script src=\"https://gist.github.com/patrykboch/3e2608d8ba474e311066d7bafe06127e.js\"></script><p>I passed the trap the following three arguments: 1) the target object for the proxy is denoted the <code class=\"language-plaintext highlighter-rouge\">trapTarget</code> 2) the <code class=\"language-plaintext highlighter-rouge\">key</code> - the property and 3) the <code class=\"language-plaintext highlighter-rouge\">receiver</code> - the proxy reference. The js object <code class=\"language-plaintext highlighter-rouge\">Reflect</code>, which describes the default behavior of js. Please note there is a <code class=\"language-plaintext highlighter-rouge\">Reflect</code> technique for each proxy trap.</p><p>To recap, operations can be intercepted using a handler and a proxy trap, which is a function that is always supplied as the second proxy argument and is in charge of the operation.<br /> <br /></p><center><div class=\"mxgraph\" style=\"max-width:100%;border:1px solid transparent;\" data-mxgraph=\"{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile modified=\\&quot;2019-04-28T10:57:51.851Z\\&quot; host=\\&quot;www.draw.io\\&quot; agent=\\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\\&quot; etag=\\&quot;KT1R89YZZIPHrD0EufzU\\&quot; version=\\&quot;10.6.5\\&quot; type=\\&quot;device\\&quot;&gt;&lt;diagram id=\\&quot;lh_yR_ml-EyFlSGjHwGa\\&quot; name=\\&quot;Page-1\\&quot;&gt;3VnfU+IwEP5rmLl70GmbttBHFfUevNE7nbnTt0BDG680TAhC/esvoUl/JMWCUnR4orvdbpJv90t2Qw9cTFfXFM7inyRESc+xwlUPDHuOY7vBgP8ITZZrAiEJRURxKI1KxT1+RVJpSe0Ch2heM2SEJAzP6soxSVM0ZjUdpJQs62YTktRHncEIGYr7MUxM7R8csjjXDjyr1P9AOIrVyLYl30yhMpaKeQxDsqyowGUPXFBCWP40XV2gRICncMm/u9rwtpgYRSnb5oMgunGePHobXi+sx+df/5wna3Di515eYLKQC76dIQoZJqmcNcsUFMsYM3Q/g2MhL3m4e+A8ZtOESzZ/lJ4QZWi1cYp2sXCeMYhMEaMZN5EfOArWTKWPlJcl9AXAcQV2ZQdltKPCdQkIf5CY7IBP38DnN5ovEvYJ4HiDrwbOwADHgAWFnE1SRMmILC9LxflawV8IWDCnXB0yShZpiMT4VgGgcPc2fHx0sqBj1J7zDNIIsbbYm+GgKOH8eKnPownb9adnlMKsYjAjOGXziuc7oSijDFwtyr7Gas3e7TdnRRnXfAZllIulvD/wanM+SOR5fGn2VwinwFHyI5dPrFPLU4rhqmo+zKrSHaKYLxlRpVxhljt0PCk+yqHFc+lKCFlHCfjRxDIyoTgyVSYMNN7n85JfvZVSrlNz5PiDuqOcOYajXVPd1SZsHGA6NbQNUC144zp0/1aLf78ZwG3no1G1I+rZh6ReQRTfrTJFMK+gTjNdhGDwrmSyVyWy3ULi7al3mD29YRP2NMYE76OerxdAOof3RD29lmijnuftRj2gn0pBi32g2fcPQSXXoNKUhHjCWdFY//LSjWlsQXP8CkdrA5GoEnZu7Z33vCHXwAUj87ypER/ABEcpf07QRLhSHDyTakZE2TjnVSROowchDE/c/VSPrlNPUeCY1WPQUDw6XRWPtllah2gC17W1NUIxfMGE9sTwV2uCThLe3q3D4icCuxF/6UdsjY6pOabQGeQADYW/3xA70FnszMqfo4f4Fjc7PuboZYHTAP+gAX27M/QDA/35DI3FxiWoAxV1jikIntUehMbmt7MoALMQexBt/+EvBow6t78lNp1dDADzZL2jZJV9+35cWVlkYaahXEHeO2hSmoeqgXi1OyCUxSQiKUyqLUK9CShtbsgaPYH5M2Isk7e1IhxNSb2XXhnIsqW1st9LU71rHe1odXRLmfu2eTdVrgKwesU7ehZX5YffqfT73U+/wVQ3HZ/Ml7LP7m9/IVXppvu1drpsoD/aTn8xdpp8Chr5tHPbrfuxPc3RntpuoDVhqpLf2Ba/bd/NhuECgxMxTMMEHVlJaQQ98IzdqKmresfhzcXyf748TuW/peDyPw==&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}\"></div><script type=\"text/javascript\" src=\"https://www.draw.io/js/viewer.min.js\"></script></center><p><br /> <br /></p><p>I’ve shown two branches on the diagram: the default behavior and the proxy’s interception of the default behavior.On the most fundamental level, default reflection yields <code class=\"language-plaintext highlighter-rouge\">undefined</code>. The same outcome is also possible with a proxy.</p><p>The second branch - <code class=\"language-plaintext highlighter-rouge\">Proxy</code> intercepts default behaviour by get trap in the handler and raises an error in the code example if property doesn’t exist.Note: <code class=\"language-plaintext highlighter-rouge\">get</code> trap is one of many others traps - <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#Methods_of_the_handler_object\">see all available traps for the <code class=\"language-plaintext highlighter-rouge\">Proxy</code></a>.</p><h2 id=\"building-two-way-data-binding-using-proxy\">Building two-way data binding using <em>Proxy</em></h2><p>Moving on let’s dive into a more complex thing. If you’re familiar with AngularJS or VueJS you’re probably into two-way data binding concept as it’s the main philosophy of these frameworks (see <a href=\"https://docs.angularjs.org/guide/databinding\">AngularJS</a> docs or <a href=\"https://vuejs.org/v2/guide/forms.html\">VueJs example of <em>v-model</em></a>)</p><blockquote>  <p>Two-way-data binding links the state with the view. If the state changes the view is updated and if the view changes the state will be updated.</p></blockquote><p>Using Proxy is the way to go if you want to create your own two-way data binding-based js framework. Our view can be connected to application state through a proxy. Consider the following illustration:<script src=\"https://gist.github.com/patrykboch/3d7b1627643facc4cbdf0ba273d4a877.js\"></script><script src=\"https://gist.github.com/patrykboch/13f5bd92ce082e698aabe2f90032e173.js\"></script><a href=\"https://jsfiddle.net/edzv5L0q/\">see live example</a></p><p>The state and the view are now bound. The view alters as the state does. First, I gave the DOM input elements a brand-new attribute called <code class=\"language-plaintext highlighter-rouge\">data-model</code>. The key component of two-way data binding is the model, which connects input value and app state. After that, I created the straightforward state interface with two keys (name and hobby).It’s good to note that only keys that have been set in the interface can be modified in a proxy; otherwise, an error will be raised if eg. <code class=\"language-plaintext highlighter-rouge\">state.strangerKey = \"Hello\"</code>. The next step is to build a proxy that has a <code class=\"language-plaintext highlighter-rouge\">set</code> trap in the handler; <code class=\"language-plaintext highlighter-rouge\">updateView</code> is added between calls to the default engine set behavior, which means that each time the state is attempted to be changed, the input values in the view will also be altered. From a view to a state direction. Also listeners have been provided to the view that detect input value changes and trigger the state change. So registering listeners on DOM elements is crucial because only registered listeners can change the state via the <code class=\"language-plaintext highlighter-rouge\">onInputChange</code> event handler.</p><p>For now, the journey with Proxy wound up, I’ve presented the most common proxy traps - <code class=\"language-plaintext highlighter-rouge\">get</code> and <code class=\"language-plaintext highlighter-rouge\">set</code> but keep in mind that Proxy supports twelve more handlers which can be used for different purposes, especially in metaprogramming.</p><p>PS. Metaprogramming rocks :).<br /></p>",
            "url": "http://localhost:4000/2022/08/12/proxy-as-the-way-of-metaprogramming-in-js",
            
            
            
            "tags": ["js","proxy","metaprogramming","reflect"],
            
            "date_published": "2022-08-12T00:00:00+02:00",
            "date_modified": "2022-08-12T00:00:00+02:00",
            
                "author":  {
                "name": "Patryk",
                "url": "boch.dev",
                "avatar": null
                }
                
            
        }
    
    ]
}