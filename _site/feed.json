{
    "version": "https://jsonfeed.org/version/1",
    "title": "boch.dev",
    "home_page_url": "http://localhost:4000/",
    "feed_url": "http://localhost:4000/feed.json",
    "description": "Simple and minimalistic jekyll blogging theme.",
    "icon": "http://localhost:4000/apple-touch-icon.png",
    "favicon": "http://localhost:4000/favicon.ico",
    "expired": false,
    
    "author": "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}",
    
"items": [
    
        {
            "id": "http://localhost:4000/2019/04/28/element-vs-html-element",
            "title": "Element vs HTMLElement",
            "summary": null,
            "content_text": "Imagine an old React component written in Typescript that renders an element with React.createElement function from top-level React API with a ref callback.class CustomComponent extends React.Component&lt;{}&gt; {  private customElement?: HTMLElement | null  // customElement is the union type (HTMLElement or null)      render() {    return React.createElement('div', {      ref: element =&gt; this.customElement = element      // element instanceof Element //=&gt; true      // element instanceof HTMLElement //=&gt; true or false     }  }}Unfortunately, typescript compiler raises an error above: Element is not assignable to HTLMElement.When I started working with DOM elements and DOM types with Typescript I was confused (as a backend dev) since I had considered every Element in the HTML dom tree as an HTMLElement before. I was suprised about the fact that HTMLElement is only the one possible type of Element (in HTML-DOM-TREE).Turned out that Element type has a wider interface scope and if using type-checking tools like Typescript we have to take care of inheritance structure then.That’s why DOM elements are commonly type-guarded or casted (always not recommended since it’s always a code smell) in order to avoid errors that devs don’t understand (including myself before).Anyways, the difference becomes important if you use type checking. What else (apart from HTMLElement) can implement the Element interface?Let’s consider a Node as the basic and generic object that represents everything which appears in a DOM tree.Node is a html tag, comment, an html element. Or let me put that the other way around - every DOM object inherits from Node.&lt;div id=\"note\"&gt;  &lt;!--Who am I?--&gt;  &lt;p&gt;Name: Max&lt;/p&gt;  &lt;p&gt;Description of myself!&lt;/p&gt;&lt;/div&gt;const element = document.getElementById('note');element.toString(); //=&gt; HTMLDivElementconst elementList = document.querySelectorAll('p');elementList.toString(); //=&gt; NodeListelementList[0].toString(); //=&gt; HTMLParagraphElementconst tags = document.getElementsByTagName('p');tags.toString(); //=&gt; HTMLCollection, list of HTMLElementstags[0].toString(); //=&gt; HTMLParagraphElementelement instanceof Node //=&gt; true element instanceof Element //=&gt; trueAn Element is a possible incarnation of a Node. So every Element is a Node, but not every Node is an Element.&lt;!--Who am I?--&gt; comment is a Node, but neither an Element nor an HTMLElement. Every node has own type and id (see all node types with its ids).element.nodeType //=&gt; 1 - it's a Node.ELEMENT_NODE with id 1element.childNodes //=&gt; NodeList(7) [text, comment, text, p, text, p, text]// lets grab &lt;!--Who am I?--&gt; commentelement.childNodes[1].nodeType //=&gt; 8 - it's a Node.COMMENT_NODE with id 8element.childNodes[1].nodeType.data //=&gt; \"Who am I?\"element.childNodes[1] instanceof Element //=&gt; falseelement.childNodes[1] instanceof Comment //=&gt; trueElement and HTMLElement: both are Nodes. Both are Elements, but Element can refer to objects different from HTML universe. And the most surprising for me is i.e to XML DOM element:&lt;!-- note.xml file --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;note&gt; &lt;name&gt;Name: Max&lt;/name&gt; &lt;description&gt;Description of myself!&lt;/description&gt;&lt;/note&gt;// fetching xml const xhttp = new XMLHttpRequest();xhttp.onreadystatechange = function() {  if (this.readyState == 4 &amp;&amp; this.status == 200) {    // check instances of xml elements    showInsanceOfElement(this)  }};xhttp.open(\"GET\", \"note.xml\", true);xhttp.send();function showInsanceOfElement(xml) {  xmlDoc = xml.responseXML;  const [xmlElement] = xmlDoc.getElementsByTagName('note');      xmlElement instanceof Element //=&gt; true  xmlElement instanceof HTMLElement //=&gt; false}And of course Element is the (grand)parent of HTMLElement children (HTMLDivElement, HTMLAnchorElement,HTML-whatever-Element). What is surprising for me - HTMLUnknownElement is an Element too:// create an unknown elementconst element = document.createElement('foo')element instanceof Element //=&gt; trueelement instanceof HTMLUnknownElement //=&gt; trueSumming up - Element could mean everything in a DOM tree and typing a DOM object to Element is not strictness and could cause a type error. That’s why I recommend in code reviews to keep it more strict (eg. as a HTMLElement or XMLElement) as a future-proof.",
            "content_html": "<p>Imagine an old React component written in Typescript that renders an element with <code class=\"highlighter-rouge\">React.createElement</code> function from top-level React API with a <code class=\"highlighter-rouge\">ref</code> callback.</p><div class=\"language-typescript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">class</span> <span class=\"nx\">CustomComponent</span> <span class=\"kd\">extends</span> <span class=\"nx\">React</span><span class=\"p\">.</span><span class=\"nx\">Component</span><span class=\"o\">&lt;</span><span class=\"p\">{}</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>  <span class=\"kr\">private</span> <span class=\"nx\">customElement</span><span class=\"p\">?:</span> <span class=\"nx\">HTMLElement</span> <span class=\"o\">|</span> <span class=\"kc\">null</span>  <span class=\"c1\">// customElement is the union type (HTMLElement or null)</span>      <span class=\"nx\">render</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">return</span> <span class=\"nx\">React</span><span class=\"p\">.</span><span class=\"nx\">createElement</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">div</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">{</span>      <span class=\"na\">ref</span><span class=\"p\">:</span> <span class=\"nx\">element</span> <span class=\"o\">=&gt;</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">customElement</span> <span class=\"o\">=</span> <span class=\"nx\">element</span>      <span class=\"c1\">// element instanceof Element //=&gt; true</span>      <span class=\"c1\">// element instanceof HTMLElement //=&gt; true or false </span>    <span class=\"p\">}</span>  <span class=\"p\">}</span><span class=\"p\">}</span></code></pre></div></div><p>Unfortunately, typescript compiler raises an error above: <em>Element is not assignable to HTLMElement</em>.</p><p>When I started working with DOM elements and DOM types with Typescript I was confused (as a backend dev) since I had considered every Element in the HTML dom tree as an HTMLElement before. I was suprised about the fact that HTMLElement is only the one possible type of Element (in HTML-DOM-TREE).</p><p>Turned out that <code class=\"highlighter-rouge\">Element</code> type has a wider interface scope and if using type-checking tools like Typescript we have to take care of inheritance structure then.That’s why DOM elements are commonly type-guarded or casted (always not recommended since it’s always a code smell) in order to avoid errors that devs don’t understand (including myself before).</p><p>Anyways, the difference becomes important if you use type checking. What else (apart from <code class=\"highlighter-rouge\">HTMLElement</code>) can implement the Element interface?</p><p>Let’s consider a <code class=\"highlighter-rouge\">Node</code> as the basic and generic object that represents everything which appears in a DOM tree.Node is a html tag, comment, an html element. Or let me put that the other way around - every DOM object inherits from Node.</p><div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nt\">&lt;div</span> <span class=\"na\">id=</span><span class=\"s\">\"note\"</span><span class=\"nt\">&gt;</span>  <span class=\"c\">&lt;!--Who am I?--&gt;</span>  <span class=\"nt\">&lt;p&gt;</span>Name: Max<span class=\"nt\">&lt;/p&gt;</span>  <span class=\"nt\">&lt;p&gt;</span>Description of myself!<span class=\"nt\">&lt;/p&gt;</span><span class=\"nt\">&lt;/div&gt;</span></code></pre></div></div><div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">const</span> <span class=\"nx\">element</span> <span class=\"o\">=</span> <span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">getElementById</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">note</span><span class=\"dl\">'</span><span class=\"p\">);</span><span class=\"nx\">element</span><span class=\"p\">.</span><span class=\"nx\">toString</span><span class=\"p\">();</span> <span class=\"c1\">//=&gt; HTMLDivElement</span><span class=\"kd\">const</span> <span class=\"nx\">elementList</span> <span class=\"o\">=</span> <span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">querySelectorAll</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">p</span><span class=\"dl\">'</span><span class=\"p\">);</span><span class=\"nx\">elementList</span><span class=\"p\">.</span><span class=\"nx\">toString</span><span class=\"p\">();</span> <span class=\"c1\">//=&gt; NodeList</span><span class=\"nx\">elementList</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"nx\">toString</span><span class=\"p\">();</span> <span class=\"c1\">//=&gt; HTMLParagraphElement</span><span class=\"kd\">const</span> <span class=\"nx\">tags</span> <span class=\"o\">=</span> <span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">getElementsByTagName</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">p</span><span class=\"dl\">'</span><span class=\"p\">);</span><span class=\"nx\">tags</span><span class=\"p\">.</span><span class=\"nx\">toString</span><span class=\"p\">();</span> <span class=\"c1\">//=&gt; HTMLCollection, list of HTMLElements</span><span class=\"nx\">tags</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"nx\">toString</span><span class=\"p\">();</span> <span class=\"c1\">//=&gt; HTMLParagraphElement</span><span class=\"nx\">element</span> <span class=\"k\">instanceof</span> <span class=\"nx\">Node</span> <span class=\"c1\">//=&gt; true </span><span class=\"nx\">element</span> <span class=\"k\">instanceof</span> <span class=\"nx\">Element</span> <span class=\"c1\">//=&gt; true</span></code></pre></div></div><p>An <code class=\"highlighter-rouge\">Element</code> is a possible incarnation of a Node. So every Element is a Node, but not every Node is an Element.<code class=\"highlighter-rouge\">&lt;!--Who am I?--&gt;</code> comment is a Node, but neither an Element nor an HTMLElement. Every node has own type and id (<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType#Node_type_constants\">see all node types with its ids</a>).</p><div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nx\">element</span><span class=\"p\">.</span><span class=\"nx\">nodeType</span> <span class=\"c1\">//=&gt; 1 - it's a Node.ELEMENT_NODE with id 1</span><span class=\"nx\">element</span><span class=\"p\">.</span><span class=\"nx\">childNodes</span> <span class=\"c1\">//=&gt; NodeList(7) [text, comment, text, p, text, p, text]</span><span class=\"c1\">// lets grab &lt;!--Who am I?--&gt; comment</span><span class=\"nx\">element</span><span class=\"p\">.</span><span class=\"nx\">childNodes</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"nx\">nodeType</span> <span class=\"c1\">//=&gt; 8 - it's a Node.COMMENT_NODE with id 8</span><span class=\"nx\">element</span><span class=\"p\">.</span><span class=\"nx\">childNodes</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"nx\">nodeType</span><span class=\"p\">.</span><span class=\"nx\">data</span> <span class=\"c1\">//=&gt; \"Who am I?\"</span><span class=\"nx\">element</span><span class=\"p\">.</span><span class=\"nx\">childNodes</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"k\">instanceof</span> <span class=\"nx\">Element</span> <span class=\"c1\">//=&gt; false</span><span class=\"nx\">element</span><span class=\"p\">.</span><span class=\"nx\">childNodes</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"k\">instanceof</span> <span class=\"nx\">Comment</span> <span class=\"c1\">//=&gt; true</span></code></pre></div></div><p>Element and HTMLElement: both are Nodes. Both are Elements, but <em>Element can refer to objects different from HTML universe.</em> And the most surprising for me is i.e to XML DOM element:</p><div class=\"language-xml highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\">&lt;!-- note.xml file --&gt;</span><span class=\"cp\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;</span><span class=\"nt\">&lt;note&gt;</span> <span class=\"nt\">&lt;name&gt;</span>Name: Max<span class=\"nt\">&lt;/name&gt;</span> <span class=\"nt\">&lt;description&gt;</span>Description of myself!<span class=\"nt\">&lt;/description&gt;</span><span class=\"nt\">&lt;/note&gt;</span></code></pre></div></div><div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// fetching xml </span><span class=\"kd\">const</span> <span class=\"nx\">xhttp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">XMLHttpRequest</span><span class=\"p\">();</span><span class=\"nx\">xhttp</span><span class=\"p\">.</span><span class=\"nx\">onreadystatechange</span> <span class=\"o\">=</span> <span class=\"kd\">function</span><span class=\"p\">()</span> <span class=\"p\">{</span>  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">readyState</span> <span class=\"o\">==</span> <span class=\"mi\">4</span> <span class=\"o\">&amp;&amp;</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">status</span> <span class=\"o\">==</span> <span class=\"mi\">200</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"c1\">// check instances of xml elements</span>    <span class=\"nx\">showInsanceOfElement</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">)</span>  <span class=\"p\">}</span><span class=\"p\">};</span><span class=\"nx\">xhttp</span><span class=\"p\">.</span><span class=\"nx\">open</span><span class=\"p\">(</span><span class=\"dl\">\"</span><span class=\"s2\">GET</span><span class=\"dl\">\"</span><span class=\"p\">,</span> <span class=\"dl\">\"</span><span class=\"s2\">note.xml</span><span class=\"dl\">\"</span><span class=\"p\">,</span> <span class=\"kc\">true</span><span class=\"p\">);</span><span class=\"nx\">xhttp</span><span class=\"p\">.</span><span class=\"nx\">send</span><span class=\"p\">();</span><span class=\"kd\">function</span> <span class=\"nx\">showInsanceOfElement</span><span class=\"p\">(</span><span class=\"nx\">xml</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"nx\">xmlDoc</span> <span class=\"o\">=</span> <span class=\"nx\">xml</span><span class=\"p\">.</span><span class=\"nx\">responseXML</span><span class=\"p\">;</span>  <span class=\"kd\">const</span> <span class=\"p\">[</span><span class=\"nx\">xmlElement</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">xmlDoc</span><span class=\"p\">.</span><span class=\"nx\">getElementsByTagName</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">note</span><span class=\"dl\">'</span><span class=\"p\">);</span>      <span class=\"nx\">xmlElement</span> <span class=\"k\">instanceof</span> <span class=\"nx\">Element</span> <span class=\"c1\">//=&gt; true</span>  <span class=\"nx\">xmlElement</span> <span class=\"k\">instanceof</span> <span class=\"nx\">HTMLElement</span> <span class=\"c1\">//=&gt; false</span><span class=\"p\">}</span></code></pre></div></div><p>And of course <code class=\"highlighter-rouge\">Element</code> is the (grand)parent of <code class=\"highlighter-rouge\">HTMLElement</code> children (<code class=\"highlighter-rouge\">HTMLDivElement</code>, <code class=\"highlighter-rouge\">HTMLAnchorElement</code>,<code class=\"highlighter-rouge\">HTML-whatever-Element</code>). What is surprising for me - <code class=\"highlighter-rouge\">HTMLUnknownElement</code> is an Element too:</p><div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// create an unknown element</span><span class=\"kd\">const</span> <span class=\"nx\">element</span> <span class=\"o\">=</span> <span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">createElement</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">foo</span><span class=\"dl\">'</span><span class=\"p\">)</span><span class=\"nx\">element</span> <span class=\"k\">instanceof</span> <span class=\"nx\">Element</span> <span class=\"c1\">//=&gt; true</span><span class=\"nx\">element</span> <span class=\"k\">instanceof</span> <span class=\"nx\">HTMLUnknownElement</span> <span class=\"c1\">//=&gt; true</span></code></pre></div></div><p>Summing up - <code class=\"highlighter-rouge\">Element</code> could mean everything in a DOM tree and typing a DOM object to Element is not strictness and could cause a type error. That’s why I recommend in code reviews to keep it more strict (eg. as a <code class=\"highlighter-rouge\">HTMLElement</code> or <code class=\"highlighter-rouge\">XMLElement</code>) as a future-proof.</p>",
            "url": "http://localhost:4000/2019/04/28/element-vs-html-element",
            
            
            
            
            
            "date_published": "2019-04-28T00:00:00+02:00",
            "date_modified": "2019-04-28T00:00:00+02:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        },
    
        {
            "id": "http://localhost:4000/2019/04/12/proxy-as-the-way-of-metaprogramming-in-js",
            "title": "Proxy as the way of metaprogramming in JS",
            "summary": "How to use Proxy es6 object in JS for metaprogramming",
            "content_text": "Important note: Proxy here is something different than one of the OOP pattern.Since I started using javascript every single after migration from backend world I’ve experienced some strange aspects of JS. One of them annoys me - undefined instead of code execution error (among others when accessing property that doesn’t exist). JS behavior in this aspect is slightly different from Ruby or Python that I’m used to...jsconst obj = { name: 'Max' };obj.name //=&gt; 'Max'obj.surname //=&gt; undefinedand a Ruby equivalent:.rbobj = { name: 'Max' }obj.fetch(:name) #=&gt; 'Max'obj.fetch(:surname) #=&gt; Error! Key not found: :surnameobj[:surname] #=&gt; nil# tl;tr obj[:surname] is not the case hereobj.fetch(:surname) #=&gt; Error! Key not found: :surname // not specified default valueobj.fetch(:surname, nil) #=&gt; nil // if key does not exist it returns (default value = nil)obj[:surname] #=&gt; nil // as above (default value = nil by default. No need to specify)obj[:surname] == obj.fetch(:surname, nil) #=&gt; true // the same behaviourThe Ruby execution is a little bit confusing since Ruby programmers are familiar with obj[:key] notation which doesn’t produce an error (better use Hash#fetch instead of Hash[:key]). A Python example is more proper:#.pyobj = { name: 'Max' }obj['name'] #=&gt; 'Max'obj['surname'] #=&gt; Error! KeyError: 'surname'Python and Ruby (with non-specified default_value) produce the errors. If a property does not exist the code execution ends with the throw. Imagine working on a big js project and small property typo breaks all results of a computation - because of undefined instead of the key not found throw - don’t know why and where since there are lots of possibly places for undefined (debugging undefined takes a long time). Don’t worry - es6 standard gives us solutions for circumventing unexpected and default javascript behavior via Proxy object.Proxy object as the way of metaprogrammingYes, since ES6 has been released JS is known as fully reflective by introducing the Reflection API for reflective (meta)programming.  Reflection is the ability of a computer program to examine, introspect, and modify its own structure and behavior at runtime.In other words, reflection means that a program can process itself on three levels (introspection, self-modification, intercession). ECMAScript 5 has provided the ability to reflective introspection and self-modification, eg. Object.keys() for introspection or Object#delete for self-modification - all Object.* methods are considered as reflective methods of metaprogramming, butneither them nor other ES5 features support the third level of reflection - behavioral level, and  that was the reason for introducing proxies in ECMAScript 6 that let us changing built-in language operations.  The Proxy object is used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc). (official docs)I’d say - using Proxies is a way for virtualizing objects (eg. POJOs). Virtualized object looks the same as a given object and any operation on it refers to an already created proxy object. In general, an object has a standard set of methods (which produce specific behavior) and by virtualization, we can take control of default behavior by intercepting and re-defining then.const object = { name: 'Max' };const proxy = new Proxy(object, {});object.name //=&gt; Maxproxy.name //=&gt; Maxobject.name = 'Claire'proxy.name //=&gt; Claireobject.name //=&gt; ClaireNothing special above, virtualization of the object and the property lookup without invoking any operations(see: no-op forwarding). If you add a property for an object, the same property for a proxy object will be added. Some kind of a symlink, but proxies are built for intercepting the low-level operations on the target object indeed. The first argument for the Proxy is a target, the second is a handler.Error instead of undefined…when accessing non-existent property with the get trap.Let’s figure out a problem mentioned at the beginning of the article. How we can change the default behoaviour that ends with undefined instead of code execution error like in Ruby or Python? At the beggining let’s describe the default behaviour with a proxy object:const object = { name: 'Max' };object.name //=&gt; Maxobject.surname //=&gt; undefined// the default js behaviour with a proxyconst proxy = new Proxy(object, { // init the proxy with the target  get(trapTarget, key, receiver) { // added the get trap      return Reflect.get(trapTarget, key, receiver) // run default behaviour    }});proxy.name //=&gt; Maxproxy.surname //=&gt; undefined// comparing proxy and object via lodash isEqual returns true// note that objects (values) in JS are incomparable via === or Object.is().isEqual(proxy, object) //=&gt; trueLet’s change the default behaviour:const object = { name: 'Max' };object.name //=&gt; Maxobject.surname //=&gt; undefined// changing the default js behaviour with a proxyconst proxy = new Proxy(object, {  get(trapTarget, key, receiver) {    if (!(key in receiver)) {      throw new TypeError(`undefined key ${key}`) // error if key does not exist    }    return Reflect.get(trapTarget, key, receiver)  // run the default behaviour  }});object.name //=&gt; Maxobject.surname //=&gt; TypeError: undefined key surnameI use the get trap to intercept default behavior when accessing the property. I passed three arguments to the trap: 1) the trapTarget - the target object for the proxy, 2) the key - the property and 3) the receiver - it’s the proxy reference.Logic ends with Reflect - the js object without constructor which expresses a default js behavior. Every proxy trap has an equivalent in a Reflect method.  Intercepting operations are possible by handler and a proxy trap - a function that is responsible for operation and it’s passed always as the second proxy argument.On the diagram I’ve displayed two branches - default behavior, and interception of a default behavior by Proxy. Default reflection on the basic level returns undefined. We can achieve the same result with proxy too.new Proxy(targetObject, {  get(target, key, receiver) {     return Reflect.get(target, key, receiver)  }; });The second branch - Proxy intercepts default behaviour by get trap in the handler and raises an error in the code example if property doesn’t exist.Note: get trap is one of many others traps - see all available traps for the Proxy.Building two-way data binding using ProxyMoving on let’s dive into a more complex thing. If you’re familiar with AngularJS or VueJS you’re probably into two-way data binding concept as it’s the main philosophy of these frameworks (see AngularJS docs or VueJs example of v-model)  Two-way-data binding links the state with the view. If the state changes the view is updated and if the view changes the state will be updated.If you want to write your own js framework based on two-way data binding then using Proxy is the way to go. A proxy can link our view with application state. Look at the following example:&lt;!-- html --&gt;&lt;div class=\"app\"&gt;  &lt;div class=\"field\"&gt;    &lt;label for=\"name\"&gt;My name is:&lt;/label&gt;    &lt;input id=\"name\" type=\"text\" name=\"name\" data-model=\"name\" /&gt;  &lt;/div&gt;  &lt;div class=\"field\"&gt;    &lt;label for=\"hobby\"&gt;My hobby is:&lt;/label&gt;    &lt;input id=\"hobby\" type=\"text\" name=\"hobby\" data-model=\"hobby\" /&gt;  &lt;/div&gt;  &lt;div class=\"app-state\"&gt;    &lt;h4 data-model=\"app-state\" /&gt;  &lt;/div&gt;&lt;/div&gt;// set a state interface (models)let stateInterface = {  name: '',  hobby: ''};// set a trap!const state = new Proxy(stateInterface, {  set(trapTarget, key, value, receiver) {    setInputValue(key, value) // update input values in the view before setting property    return Reflect.set(trapTarget, key, value, receiver); // call default set behaviour  },});// set default valuesstate.name = 'John'state.hobby = 'Football'// find input DOM element and update its value with a state value// linking state with the viewfunction setInputValue(id, value) {  document.querySelector(`[data-model=\"${id}\"]`).value = value;}// change the app state when input value changes in the DOM// linking view with the statefunction onInputChange(event) {  state[event.target.dataset.model] = event.target.value;};// add listeners to inputsObject.keys(stateInterface).map(id =&gt; {  const element = document.querySelector(`[data-model=\"${id}\"]`)  element.addEventListener('keyup', onInputChange)})see live exampleThe view and the state - two things have been linked. Changing the state changes the view. At first, I added a new attributedata-model to the DOM input elements. The model links input value with the app state, so that’s the main part of two-way data binding. I designed the simple state interface afterwards that contains two keys (name and hobby). The important thing - only keys that are set in the interface can be updated in a proxy - i.e. state.strangerKey = 'Hello' will raise an error.Next thing is creating a proxy with set trap in the handler. Between calling default engine set behaviour we added updateView - it means that every attempt of setting state will update the input values in the view. From a view to a state direction.I implemented listeners that listen to input value changes in the view and trigger the state change. So the important thing is registering listeners on DOM elements as only registered listeners can change the state via onInputChange event handler.The journey with Proxy wound up, I presented the most common proxy traps - get and set but keep in mind that Proxy supports twelve more handlers which can be used for different purposes, especially in metaprogramming.PS. Metaprogramming rocks :).",
            "content_html": "<p>Important note: <em>Proxy</em> here is something different than one of the OOP pattern.</p><p>Since I started using javascript every single after migration from backend world I’ve experienced some strange aspects of JS. One of them annoys me - <em>undefined</em> instead of code execution error (among others when accessing property that doesn’t exist). JS behavior in this aspect is slightly different from Ruby or Python that I’m used to..</p><div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"p\">.</span><span class=\"nx\">js</span><span class=\"kd\">const</span> <span class=\"nx\">obj</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"na\">name</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Max</span><span class=\"dl\">'</span> <span class=\"p\">};</span><span class=\"nx\">obj</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"c1\">//=&gt; 'Max'</span><span class=\"nx\">obj</span><span class=\"p\">.</span><span class=\"nx\">surname</span> <span class=\"c1\">//=&gt; undefined</span></code></pre></div></div><p>and a Ruby equivalent:</p><div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"p\">.</span><span class=\"nf\">rb</span><span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"ss\">name: </span><span class=\"s1\">'Max'</span> <span class=\"p\">}</span><span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"nf\">fetch</span><span class=\"p\">(</span><span class=\"ss\">:name</span><span class=\"p\">)</span> <span class=\"c1\">#=&gt; 'Max'</span><span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"nf\">fetch</span><span class=\"p\">(</span><span class=\"ss\">:surname</span><span class=\"p\">)</span> <span class=\"c1\">#=&gt; Error! Key not found: :surname</span><span class=\"n\">obj</span><span class=\"p\">[</span><span class=\"ss\">:surname</span><span class=\"p\">]</span> <span class=\"c1\">#=&gt; nil</span><span class=\"c1\"># tl;tr obj[:surname] is not the case here</span><span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"nf\">fetch</span><span class=\"p\">(</span><span class=\"ss\">:surname</span><span class=\"p\">)</span> <span class=\"c1\">#=&gt; Error! Key not found: :surname // not specified default value</span><span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"nf\">fetch</span><span class=\"p\">(</span><span class=\"ss\">:surname</span><span class=\"p\">,</span> <span class=\"kp\">nil</span><span class=\"p\">)</span> <span class=\"c1\">#=&gt; nil // if key does not exist it returns (default value = nil)</span><span class=\"n\">obj</span><span class=\"p\">[</span><span class=\"ss\">:surname</span><span class=\"p\">]</span> <span class=\"c1\">#=&gt; nil // as above (default value = nil by default. No need to specify)</span><span class=\"n\">obj</span><span class=\"p\">[</span><span class=\"ss\">:surname</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"nf\">fetch</span><span class=\"p\">(</span><span class=\"ss\">:surname</span><span class=\"p\">,</span> <span class=\"kp\">nil</span><span class=\"p\">)</span> <span class=\"c1\">#=&gt; true // the same behaviour</span></code></pre></div></div><p>The Ruby execution is a little bit confusing since Ruby programmers are familiar with <code class=\"highlighter-rouge\">obj[:key]</code> notation which doesn’t produce an error (better use <code class=\"highlighter-rouge\">Hash#fetch</code> instead of <code class=\"highlighter-rouge\">Hash[:key]</code>). A Python example is more proper:</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">#.py</span><span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"s\">'Max'</span> <span class=\"p\">}</span><span class=\"n\">obj</span><span class=\"p\">[</span><span class=\"s\">'name'</span><span class=\"p\">]</span> <span class=\"c1\">#=&gt; 'Max'</span><span class=\"n\">obj</span><span class=\"p\">[</span><span class=\"s\">'surname'</span><span class=\"p\">]</span> <span class=\"c1\">#=&gt; Error! KeyError: 'surname'</span></code></pre></div></div><p>Python and Ruby (with non-specified <code class=\"highlighter-rouge\">default_value</code>) produce the errors. If a property does not exist the code execution ends with the throw. Imagine working on a big js project and small property typo breaks all results of a computation - because of <em>undefined</em> instead of the <em>key not found</em> throw - don’t know why and where since there are lots of possibly places for <em>undefined</em> (debugging undefined takes a long time). Don’t worry - es6 standard gives us solutions for circumventing unexpected and default javascript behavior via Proxy object.</p><h3 id=\"proxy-object-as-the-way-of-metaprogramming\">Proxy object as the way of metaprogramming</h3><p>Yes, since ES6 has been released JS is known as fully reflective by introducing the <em>Reflection API</em> for <em>reflective (meta)programming</em>.</p><blockquote>  <p>Reflection is the ability of a computer program to examine, introspect, and modify its own structure and behavior at runtime.</p></blockquote><p>In other words, reflection means that a program can process itself on three levels (<em>introspection</em>, <em>self-modification</em>, <em>intercession</em>). ECMAScript 5 has provided the ability to reflective introspection and self-modification, eg. <code class=\"highlighter-rouge\">Object.keys()</code> for introspection or <code class=\"highlighter-rouge\">Object#delete</code> for <code class=\"highlighter-rouge\">self-modification</code> - all <code class=\"highlighter-rouge\">Object.*</code> methods are considered as reflective methods of metaprogramming, butneither them nor other ES5 features support the third level of reflection - <em>behavioral level</em>, and  that was the reason for introducing proxies in ECMAScript 6 that let us changing built-in language operations.</p><blockquote>  <p>The Proxy object is used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc). <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Meta_programming\">(official docs)</a></p></blockquote><p>I’d say - using Proxies is a way for virtualizing objects (eg. POJOs). Virtualized object looks the same as a given object and any operation on it refers to an already created proxy object. In general, an object has a standard set of methods (which produce specific behavior) and by virtualization, we can take control of default behavior by intercepting and re-defining then.</p><div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">const</span> <span class=\"nx\">object</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"na\">name</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Max</span><span class=\"dl\">'</span> <span class=\"p\">};</span><span class=\"kd\">const</span> <span class=\"nx\">proxy</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nb\">Proxy</span><span class=\"p\">(</span><span class=\"nx\">object</span><span class=\"p\">,</span> <span class=\"p\">{});</span><span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"c1\">//=&gt; Max</span><span class=\"nx\">proxy</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"c1\">//=&gt; Max</span><span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"dl\">'</span><span class=\"s1\">Claire</span><span class=\"dl\">'</span><span class=\"nx\">proxy</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"c1\">//=&gt; Claire</span><span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"c1\">//=&gt; Claire</span></code></pre></div></div><p>Nothing special above, virtualization of the object and the property lookup without invoking any operations(see: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#No-op_forwarding_proxy\">no-op forwarding</a>). If you add a property for an object, the same property for a proxy object will be added. Some kind of a symlink, but proxies are built for intercepting the low-level operations on the target object indeed. The first argument for the Proxy is a target, the second is a handler.</p><h3 id=\"error-instead-of-undefined\">Error instead of <em>undefined</em></h3><p><em>…when accessing non-existent property with the <code class=\"highlighter-rouge\">get</code> trap.</em></p><p>Let’s figure out a problem mentioned at the beginning of the article. How we can change the default behoaviour that ends with <em>undefined</em> instead of code execution error like in Ruby or Python? At the beggining let’s describe the default behaviour with a proxy object:</p><div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">const</span> <span class=\"nx\">object</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"na\">name</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Max</span><span class=\"dl\">'</span> <span class=\"p\">};</span><span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"c1\">//=&gt; Max</span><span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">surname</span> <span class=\"c1\">//=&gt; undefined</span><span class=\"c1\">// the default js behaviour with a proxy</span><span class=\"kd\">const</span> <span class=\"nx\">proxy</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nb\">Proxy</span><span class=\"p\">(</span><span class=\"nx\">object</span><span class=\"p\">,</span> <span class=\"p\">{</span> <span class=\"c1\">// init the proxy with the target</span>  <span class=\"kd\">get</span><span class=\"p\">(</span><span class=\"nx\">trapTarget</span><span class=\"p\">,</span> <span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"nx\">receiver</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// added the get trap</span>      <span class=\"k\">return</span> <span class=\"nb\">Reflect</span><span class=\"p\">.</span><span class=\"kd\">get</span><span class=\"p\">(</span><span class=\"nx\">trapTarget</span><span class=\"p\">,</span> <span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"nx\">receiver</span><span class=\"p\">)</span> <span class=\"c1\">// run default behaviour</span>    <span class=\"p\">}</span><span class=\"p\">});</span><span class=\"nx\">proxy</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"c1\">//=&gt; Max</span><span class=\"nx\">proxy</span><span class=\"p\">.</span><span class=\"nx\">surname</span> <span class=\"c1\">//=&gt; undefined</span><span class=\"c1\">// comparing proxy and object via lodash isEqual returns true</span><span class=\"c1\">// note that objects (values) in JS are incomparable via === or Object.is().</span><span class=\"nx\">isEqual</span><span class=\"p\">(</span><span class=\"nx\">proxy</span><span class=\"p\">,</span> <span class=\"nx\">object</span><span class=\"p\">)</span> <span class=\"c1\">//=&gt; true</span></code></pre></div></div><p>Let’s change the default behaviour:</p><div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">const</span> <span class=\"nx\">object</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"na\">name</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Max</span><span class=\"dl\">'</span> <span class=\"p\">};</span><span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"c1\">//=&gt; Max</span><span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">surname</span> <span class=\"c1\">//=&gt; undefined</span><span class=\"c1\">// changing the default js behaviour with a proxy</span><span class=\"kd\">const</span> <span class=\"nx\">proxy</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nb\">Proxy</span><span class=\"p\">(</span><span class=\"nx\">object</span><span class=\"p\">,</span> <span class=\"p\">{</span>  <span class=\"kd\">get</span><span class=\"p\">(</span><span class=\"nx\">trapTarget</span><span class=\"p\">,</span> <span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"nx\">receiver</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"nx\">key</span> <span class=\"k\">in</span> <span class=\"nx\">receiver</span><span class=\"p\">))</span> <span class=\"p\">{</span>      <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nx\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">`undefined key </span><span class=\"p\">${</span><span class=\"nx\">key</span><span class=\"p\">}</span><span class=\"s2\">`</span><span class=\"p\">)</span> <span class=\"c1\">// error if key does not exist</span>    <span class=\"p\">}</span>    <span class=\"k\">return</span> <span class=\"nb\">Reflect</span><span class=\"p\">.</span><span class=\"kd\">get</span><span class=\"p\">(</span><span class=\"nx\">trapTarget</span><span class=\"p\">,</span> <span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"nx\">receiver</span><span class=\"p\">)</span>  <span class=\"c1\">// run the default behaviour</span>  <span class=\"p\">}</span><span class=\"p\">});</span><span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"c1\">//=&gt; Max</span><span class=\"nx\">object</span><span class=\"p\">.</span><span class=\"nx\">surname</span> <span class=\"c1\">//=&gt; TypeError: undefined key surname</span></code></pre></div></div><p>I use the <code class=\"highlighter-rouge\">get</code> trap to intercept default behavior when accessing the property. I passed three arguments to the trap: 1) the <code class=\"highlighter-rouge\">trapTarget</code> - the target object for the proxy, 2) the <code class=\"highlighter-rouge\">key</code> - the property and 3) the <code class=\"highlighter-rouge\">receiver</code> - it’s the proxy reference.Logic ends with <code class=\"highlighter-rouge\">Reflect</code> - the js object without constructor which expresses a default js behavior. Every proxy trap has an equivalent in a <code class=\"highlighter-rouge\">Reflect</code> method.<br /> <br /></p><center><div class=\"mxgraph\" style=\"max-width:100%;border:1px solid transparent;\" data-mxgraph=\"{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile modified=\\&quot;2019-04-28T10:57:51.851Z\\&quot; host=\\&quot;www.draw.io\\&quot; agent=\\&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\\&quot; etag=\\&quot;KT1R89YZZIPHrD0EufzU\\&quot; version=\\&quot;10.6.5\\&quot; type=\\&quot;device\\&quot;&gt;&lt;diagram id=\\&quot;lh_yR_ml-EyFlSGjHwGa\\&quot; name=\\&quot;Page-1\\&quot;&gt;3VnfU+IwEP5rmLl70GmbttBHFfUevNE7nbnTt0BDG680TAhC/esvoUl/JMWCUnR4orvdbpJv90t2Qw9cTFfXFM7inyRESc+xwlUPDHuOY7vBgP8ITZZrAiEJRURxKI1KxT1+RVJpSe0Ch2heM2SEJAzP6soxSVM0ZjUdpJQs62YTktRHncEIGYr7MUxM7R8csjjXDjyr1P9AOIrVyLYl30yhMpaKeQxDsqyowGUPXFBCWP40XV2gRICncMm/u9rwtpgYRSnb5oMgunGePHobXi+sx+df/5wna3Di515eYLKQC76dIQoZJqmcNcsUFMsYM3Q/g2MhL3m4e+A8ZtOESzZ/lJ4QZWi1cYp2sXCeMYhMEaMZN5EfOArWTKWPlJcl9AXAcQV2ZQdltKPCdQkIf5CY7IBP38DnN5ovEvYJ4HiDrwbOwADHgAWFnE1SRMmILC9LxflawV8IWDCnXB0yShZpiMT4VgGgcPc2fHx0sqBj1J7zDNIIsbbYm+GgKOH8eKnPownb9adnlMKsYjAjOGXziuc7oSijDFwtyr7Gas3e7TdnRRnXfAZllIulvD/wanM+SOR5fGn2VwinwFHyI5dPrFPLU4rhqmo+zKrSHaKYLxlRpVxhljt0PCk+yqHFc+lKCFlHCfjRxDIyoTgyVSYMNN7n85JfvZVSrlNz5PiDuqOcOYajXVPd1SZsHGA6NbQNUC144zp0/1aLf78ZwG3no1G1I+rZh6ReQRTfrTJFMK+gTjNdhGDwrmSyVyWy3ULi7al3mD29YRP2NMYE76OerxdAOof3RD29lmijnuftRj2gn0pBi32g2fcPQSXXoNKUhHjCWdFY//LSjWlsQXP8CkdrA5GoEnZu7Z33vCHXwAUj87ypER/ABEcpf07QRLhSHDyTakZE2TjnVSROowchDE/c/VSPrlNPUeCY1WPQUDw6XRWPtllah2gC17W1NUIxfMGE9sTwV2uCThLe3q3D4icCuxF/6UdsjY6pOabQGeQADYW/3xA70FnszMqfo4f4Fjc7PuboZYHTAP+gAX27M/QDA/35DI3FxiWoAxV1jikIntUehMbmt7MoALMQexBt/+EvBow6t78lNp1dDADzZL2jZJV9+35cWVlkYaahXEHeO2hSmoeqgXi1OyCUxSQiKUyqLUK9CShtbsgaPYH5M2Isk7e1IhxNSb2XXhnIsqW1st9LU71rHe1odXRLmfu2eTdVrgKwesU7ehZX5YffqfT73U+/wVQ3HZ/Ml7LP7m9/IVXppvu1drpsoD/aTn8xdpp8Chr5tHPbrfuxPc3RntpuoDVhqpLf2Ba/bd/NhuECgxMxTMMEHVlJaQQ98IzdqKmresfhzcXyf748TuW/peDyPw==&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}\"></div><script type=\"text/javascript\" src=\"https://www.draw.io/js/viewer.min.js\"></script></center><p><br /> <br /></p><p>Intercepting operations are possible by handler and a proxy trap - a function that is responsible for operation and it’s passed always as the second proxy argument.On the diagram I’ve displayed two branches - default behavior, and interception of a default behavior by Proxy. Default reflection on the basic level returns <code class=\"highlighter-rouge\">undefined</code>. We can achieve the same result with proxy too.</p><div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">new</span> <span class=\"nb\">Proxy</span><span class=\"p\">(</span><span class=\"nx\">targetObject</span><span class=\"p\">,</span> <span class=\"p\">{</span>  <span class=\"kd\">get</span><span class=\"p\">(</span><span class=\"nx\">target</span><span class=\"p\">,</span> <span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"nx\">receiver</span><span class=\"p\">)</span> <span class=\"p\">{</span>     <span class=\"k\">return</span> <span class=\"nb\">Reflect</span><span class=\"p\">.</span><span class=\"kd\">get</span><span class=\"p\">(</span><span class=\"nx\">target</span><span class=\"p\">,</span> <span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"nx\">receiver</span><span class=\"p\">)</span>  <span class=\"p\">};</span> <span class=\"p\">});</span></code></pre></div></div><p>The second branch - <code class=\"highlighter-rouge\">Proxy</code> intercepts default behaviour by get trap in the handler and raises an error in the code example if property doesn’t exist.Note: <code class=\"highlighter-rouge\">get</code> trap is one of many others traps - <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#Methods_of_the_handler_object\">see all available traps for the <code class=\"highlighter-rouge\">Proxy</code></a>.</p><h3 id=\"building-two-way-data-binding-using-proxy\">Building two-way data binding using <em>Proxy</em></h3><p>Moving on let’s dive into a more complex thing. If you’re familiar with AngularJS or VueJS you’re probably into two-way data binding concept as it’s the main philosophy of these frameworks (see <a href=\"https://docs.angularjs.org/guide/databinding\">AngularJS</a> docs or <a href=\"https://vuejs.org/v2/guide/forms.html\">VueJs example of <em>v-model</em></a>)</p><blockquote>  <p>Two-way-data binding links the state with the view. If the state changes the view is updated and if the view changes the state will be updated.</p></blockquote><p>If you want to write your own js framework based on two-way data binding then using Proxy is the way to go. A proxy can link our view with application state. Look at the following example:</p><div class=\"language-html highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\">&lt;!-- html --&gt;</span><span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">\"app\"</span><span class=\"nt\">&gt;</span>  <span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">\"field\"</span><span class=\"nt\">&gt;</span>    <span class=\"nt\">&lt;label</span> <span class=\"na\">for=</span><span class=\"s\">\"name\"</span><span class=\"nt\">&gt;</span>My name is:<span class=\"nt\">&lt;/label&gt;</span>    <span class=\"nt\">&lt;input</span> <span class=\"na\">id=</span><span class=\"s\">\"name\"</span> <span class=\"na\">type=</span><span class=\"s\">\"text\"</span> <span class=\"na\">name=</span><span class=\"s\">\"name\"</span> <span class=\"na\">data-model=</span><span class=\"s\">\"name\"</span> <span class=\"nt\">/&gt;</span>  <span class=\"nt\">&lt;/div&gt;</span>  <span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">\"field\"</span><span class=\"nt\">&gt;</span>    <span class=\"nt\">&lt;label</span> <span class=\"na\">for=</span><span class=\"s\">\"hobby\"</span><span class=\"nt\">&gt;</span>My hobby is:<span class=\"nt\">&lt;/label&gt;</span>    <span class=\"nt\">&lt;input</span> <span class=\"na\">id=</span><span class=\"s\">\"hobby\"</span> <span class=\"na\">type=</span><span class=\"s\">\"text\"</span> <span class=\"na\">name=</span><span class=\"s\">\"hobby\"</span> <span class=\"na\">data-model=</span><span class=\"s\">\"hobby\"</span> <span class=\"nt\">/&gt;</span>  <span class=\"nt\">&lt;/div&gt;</span>  <span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">\"app-state\"</span><span class=\"nt\">&gt;</span>    <span class=\"nt\">&lt;h4</span> <span class=\"na\">data-model=</span><span class=\"s\">\"app-state\"</span> <span class=\"nt\">/&gt;</span>  <span class=\"nt\">&lt;/div&gt;</span><span class=\"nt\">&lt;/div&gt;</span></code></pre></div></div><div class=\"language-javascript highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// set a state interface (models)</span><span class=\"kd\">let</span> <span class=\"nx\">stateInterface</span> <span class=\"o\">=</span> <span class=\"p\">{</span>  <span class=\"na\">name</span><span class=\"p\">:</span> <span class=\"dl\">''</span><span class=\"p\">,</span>  <span class=\"na\">hobby</span><span class=\"p\">:</span> <span class=\"dl\">''</span><span class=\"p\">};</span><span class=\"c1\">// set a trap!</span><span class=\"kd\">const</span> <span class=\"nx\">state</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nb\">Proxy</span><span class=\"p\">(</span><span class=\"nx\">stateInterface</span><span class=\"p\">,</span> <span class=\"p\">{</span>  <span class=\"kd\">set</span><span class=\"p\">(</span><span class=\"nx\">trapTarget</span><span class=\"p\">,</span> <span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"nx\">value</span><span class=\"p\">,</span> <span class=\"nx\">receiver</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"nx\">setInputValue</span><span class=\"p\">(</span><span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"nx\">value</span><span class=\"p\">)</span> <span class=\"c1\">// update input values in the view before setting property</span>    <span class=\"k\">return</span> <span class=\"nb\">Reflect</span><span class=\"p\">.</span><span class=\"kd\">set</span><span class=\"p\">(</span><span class=\"nx\">trapTarget</span><span class=\"p\">,</span> <span class=\"nx\">key</span><span class=\"p\">,</span> <span class=\"nx\">value</span><span class=\"p\">,</span> <span class=\"nx\">receiver</span><span class=\"p\">);</span> <span class=\"c1\">// call default set behaviour</span>  <span class=\"p\">},</span><span class=\"p\">});</span><span class=\"c1\">// set default values</span><span class=\"nx\">state</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"dl\">'</span><span class=\"s1\">John</span><span class=\"dl\">'</span><span class=\"nx\">state</span><span class=\"p\">.</span><span class=\"nx\">hobby</span> <span class=\"o\">=</span> <span class=\"dl\">'</span><span class=\"s1\">Football</span><span class=\"dl\">'</span><span class=\"c1\">// find input DOM element and update its value with a state value</span><span class=\"c1\">// linking state with the view</span><span class=\"kd\">function</span> <span class=\"nx\">setInputValue</span><span class=\"p\">(</span><span class=\"nx\">id</span><span class=\"p\">,</span> <span class=\"nx\">value</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">querySelector</span><span class=\"p\">(</span><span class=\"s2\">`[data-model=\"</span><span class=\"p\">${</span><span class=\"nx\">id</span><span class=\"p\">}</span><span class=\"s2\">\"]`</span><span class=\"p\">).</span><span class=\"nx\">value</span> <span class=\"o\">=</span> <span class=\"nx\">value</span><span class=\"p\">;</span><span class=\"p\">}</span><span class=\"c1\">// change the app state when input value changes in the DOM</span><span class=\"c1\">// linking view with the state</span><span class=\"kd\">function</span> <span class=\"nx\">onInputChange</span><span class=\"p\">(</span><span class=\"nx\">event</span><span class=\"p\">)</span> <span class=\"p\">{</span>  <span class=\"nx\">state</span><span class=\"p\">[</span><span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">target</span><span class=\"p\">.</span><span class=\"nx\">dataset</span><span class=\"p\">.</span><span class=\"nx\">model</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">target</span><span class=\"p\">.</span><span class=\"nx\">value</span><span class=\"p\">;</span><span class=\"p\">};</span><span class=\"c1\">// add listeners to inputs</span><span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">keys</span><span class=\"p\">(</span><span class=\"nx\">stateInterface</span><span class=\"p\">).</span><span class=\"nx\">map</span><span class=\"p\">(</span><span class=\"nx\">id</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>  <span class=\"kd\">const</span> <span class=\"nx\">element</span> <span class=\"o\">=</span> <span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">querySelector</span><span class=\"p\">(</span><span class=\"s2\">`[data-model=\"</span><span class=\"p\">${</span><span class=\"nx\">id</span><span class=\"p\">}</span><span class=\"s2\">\"]`</span><span class=\"p\">)</span>  <span class=\"nx\">element</span><span class=\"p\">.</span><span class=\"nx\">addEventListener</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">keyup</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"nx\">onInputChange</span><span class=\"p\">)</span><span class=\"p\">})</span></code></pre></div></div><p><a href=\"https://jsfiddle.net/edzv5L0q/\">see live example</a><br /></p><p>The view and the state - two things have been linked. Changing the state changes the view. At first, I added a new attribute<code class=\"highlighter-rouge\">data-model</code> to the DOM input elements. The model links input value with the app state, so that’s the main part of two-way data binding. I designed the simple state interface afterwards that contains two keys (name and hobby). The important thing - only keys that are set in the interface can be updated in a proxy - i.e. <code class=\"highlighter-rouge\">state.strangerKey = 'Hello'</code> will raise an error.Next thing is creating a proxy with <code class=\"highlighter-rouge\">set</code> trap in the handler. Between calling default engine set behaviour we added <code class=\"highlighter-rouge\">updateView</code> - it means that every attempt of setting state will update the input values in the view. From a view to a state direction.I implemented listeners that listen to input value changes in the view and trigger the state change. So the important thing is registering listeners on DOM elements as only registered listeners can change the state via <code class=\"highlighter-rouge\">onInputChange</code> event handler.</p><p>The journey with Proxy wound up, I presented the most common proxy traps - get and set but keep in mind that Proxy supports twelve more handlers which can be used for different purposes, especially in metaprogramming.</p><p>PS. Metaprogramming rocks :).<br /></p>",
            "url": "http://localhost:4000/2019/04/12/proxy-as-the-way-of-metaprogramming-in-js",
            
            
            
            "tags": ["js","proxy","metaprogramming","reflect"],
            
            "date_published": "2019-04-12T00:00:00+02:00",
            "date_modified": "2019-04-12T00:00:00+02:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        }
    
    ]
}