<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-Y7YWNPD60C"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-Y7YWNPD60C'); </script><meta name="generator" content="Jekyll v4.0.0" /><meta property="og:title" content="Element vs HTMLElement" /><meta property="og:locale" content="en_US" /><meta name="description" content="Imagine an old React component written in Typescript that renders an element with React.createElement function from top-level React API with a ref callback. class CustomComponent extends React.Component&lt;{}&gt; { private customElement?: HTMLElement | null // customElement is the union type (HTMLElement or null) render() { return React.createElement(&#39;div&#39;, { ref: element =&gt; this.customElement = element // element instanceof Element //=&gt; true // element instanceof HTMLElement //=&gt; true or false } } } Unfortunately, typescript compiler raises an error above: Element is not assignable to HTLMElement. When I started working with DOM elements and DOM types with Typescript I was confused (as a backend dev) since I had considered every Element in the HTML dom tree as an HTMLElement before. I was suprised about the fact that HTMLElement is only the one possible type of Element (in HTML-DOM-TREE). Turned out that Element type has a wider interface scope and if using type-checking tools like Typescript we have to take care of inheritance structure then. That’s why DOM elements are commonly type-guarded or casted (always not recommended since it’s always a code smell) in order to avoid errors that devs don’t understand (including myself before). Anyways, the difference becomes important if you use type checking. What else (apart from HTMLElement) can implement the Element interface? Let’s consider a Node as the basic and generic object that represents everything which appears in a DOM tree. Node is a html tag, comment, an html element. Or let me put that the other way around - every DOM object inherits from Node. &lt;div id=&quot;note&quot;&gt; &lt;!--Who am I?--&gt; &lt;p&gt;Name: Max&lt;/p&gt; &lt;p&gt;Description of myself!&lt;/p&gt; &lt;/div&gt; const element = document.getElementById(&#39;note&#39;); element.toString(); //=&gt; HTMLDivElement const elementList = document.querySelectorAll(&#39;p&#39;); elementList.toString(); //=&gt; NodeList elementList[0].toString(); //=&gt; HTMLParagraphElement const tags = document.getElementsByTagName(&#39;p&#39;); tags.toString(); //=&gt; HTMLCollection, list of HTMLElements tags[0].toString(); //=&gt; HTMLParagraphElement element instanceof Node //=&gt; true element instanceof Element //=&gt; true An Element is a possible incarnation of a Node. So every Element is a Node, but not every Node is an Element. &lt;!--Who am I?--&gt; comment is a Node, but neither an Element nor an HTMLElement. Every node has own type and id (see all node types with its ids). element.nodeType //=&gt; 1 - it&#39;s a Node.ELEMENT_NODE with id 1 element.childNodes //=&gt; NodeList(7) [text, comment, text, p, text, p, text] // lets grab &lt;!--Who am I?--&gt; comment element.childNodes[1].nodeType //=&gt; 8 - it&#39;s a Node.COMMENT_NODE with id 8 element.childNodes[1].nodeType.data //=&gt; &quot;Who am I?&quot; element.childNodes[1] instanceof Element //=&gt; false element.childNodes[1] instanceof Comment //=&gt; true Element and HTMLElement: both are Nodes. Both are Elements, but Element can refer to objects different from HTML universe. And the most surprising for me is i.e to XML DOM element: &lt;!-- note.xml file --&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;note&gt; &lt;name&gt;Name: Max&lt;/name&gt; &lt;description&gt;Description of myself!&lt;/description&gt; &lt;/note&gt; // fetching xml const xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() { if (this.readyState == 4 &amp;&amp; this.status == 200) { // check instances of xml elements showInsanceOfElement(this) } }; xhttp.open(&quot;GET&quot;, &quot;note.xml&quot;, true); xhttp.send(); function showInsanceOfElement(xml) { xmlDoc = xml.responseXML; const [xmlElement] = xmlDoc.getElementsByTagName(&#39;note&#39;); xmlElement instanceof Element //=&gt; true xmlElement instanceof HTMLElement //=&gt; false } And of course Element is the (grand)parent of HTMLElement children (HTMLDivElement, HTMLAnchorElement,HTML-whatever-Element). What is surprising for me - HTMLUnknownElement is an Element too: // create an unknown element const element = document.createElement(&#39;foo&#39;) element instanceof Element //=&gt; true element instanceof HTMLUnknownElement //=&gt; true Summing up - Element could mean everything in a DOM tree and typing a DOM object to Element is not strictness and could cause a type error. That’s why I recommend in code reviews to keep it more strict (eg. as a HTMLElement or XMLElement) as a future-proof." /><meta property="og:description" content="Imagine an old React component written in Typescript that renders an element with React.createElement function from top-level React API with a ref callback. class CustomComponent extends React.Component&lt;{}&gt; { private customElement?: HTMLElement | null // customElement is the union type (HTMLElement or null) render() { return React.createElement(&#39;div&#39;, { ref: element =&gt; this.customElement = element // element instanceof Element //=&gt; true // element instanceof HTMLElement //=&gt; true or false } } } Unfortunately, typescript compiler raises an error above: Element is not assignable to HTLMElement. When I started working with DOM elements and DOM types with Typescript I was confused (as a backend dev) since I had considered every Element in the HTML dom tree as an HTMLElement before. I was suprised about the fact that HTMLElement is only the one possible type of Element (in HTML-DOM-TREE). Turned out that Element type has a wider interface scope and if using type-checking tools like Typescript we have to take care of inheritance structure then. That’s why DOM elements are commonly type-guarded or casted (always not recommended since it’s always a code smell) in order to avoid errors that devs don’t understand (including myself before). Anyways, the difference becomes important if you use type checking. What else (apart from HTMLElement) can implement the Element interface? Let’s consider a Node as the basic and generic object that represents everything which appears in a DOM tree. Node is a html tag, comment, an html element. Or let me put that the other way around - every DOM object inherits from Node. &lt;div id=&quot;note&quot;&gt; &lt;!--Who am I?--&gt; &lt;p&gt;Name: Max&lt;/p&gt; &lt;p&gt;Description of myself!&lt;/p&gt; &lt;/div&gt; const element = document.getElementById(&#39;note&#39;); element.toString(); //=&gt; HTMLDivElement const elementList = document.querySelectorAll(&#39;p&#39;); elementList.toString(); //=&gt; NodeList elementList[0].toString(); //=&gt; HTMLParagraphElement const tags = document.getElementsByTagName(&#39;p&#39;); tags.toString(); //=&gt; HTMLCollection, list of HTMLElements tags[0].toString(); //=&gt; HTMLParagraphElement element instanceof Node //=&gt; true element instanceof Element //=&gt; true An Element is a possible incarnation of a Node. So every Element is a Node, but not every Node is an Element. &lt;!--Who am I?--&gt; comment is a Node, but neither an Element nor an HTMLElement. Every node has own type and id (see all node types with its ids). element.nodeType //=&gt; 1 - it&#39;s a Node.ELEMENT_NODE with id 1 element.childNodes //=&gt; NodeList(7) [text, comment, text, p, text, p, text] // lets grab &lt;!--Who am I?--&gt; comment element.childNodes[1].nodeType //=&gt; 8 - it&#39;s a Node.COMMENT_NODE with id 8 element.childNodes[1].nodeType.data //=&gt; &quot;Who am I?&quot; element.childNodes[1] instanceof Element //=&gt; false element.childNodes[1] instanceof Comment //=&gt; true Element and HTMLElement: both are Nodes. Both are Elements, but Element can refer to objects different from HTML universe. And the most surprising for me is i.e to XML DOM element: &lt;!-- note.xml file --&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;note&gt; &lt;name&gt;Name: Max&lt;/name&gt; &lt;description&gt;Description of myself!&lt;/description&gt; &lt;/note&gt; // fetching xml const xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() { if (this.readyState == 4 &amp;&amp; this.status == 200) { // check instances of xml elements showInsanceOfElement(this) } }; xhttp.open(&quot;GET&quot;, &quot;note.xml&quot;, true); xhttp.send(); function showInsanceOfElement(xml) { xmlDoc = xml.responseXML; const [xmlElement] = xmlDoc.getElementsByTagName(&#39;note&#39;); xmlElement instanceof Element //=&gt; true xmlElement instanceof HTMLElement //=&gt; false } And of course Element is the (grand)parent of HTMLElement children (HTMLDivElement, HTMLAnchorElement,HTML-whatever-Element). What is surprising for me - HTMLUnknownElement is an Element too: // create an unknown element const element = document.createElement(&#39;foo&#39;) element instanceof Element //=&gt; true element instanceof HTMLUnknownElement //=&gt; true Summing up - Element could mean everything in a DOM tree and typing a DOM object to Element is not strictness and could cause a type error. That’s why I recommend in code reviews to keep it more strict (eg. as a HTMLElement or XMLElement) as a future-proof." /><link rel="canonical" href="http://localhost:4000/2019/04/28/element-vs-html-element" /><meta property="og:url" content="http://localhost:4000/2019/04/28/element-vs-html-element" /><meta property="og:site_name" content="boch.dev" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-04-28T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Element vs HTMLElement" /><meta name="twitter:site" content="@" /> <script type="application/ld+json"> {"description":"Imagine an old React component written in Typescript that renders an element with React.createElement function from top-level React API with a ref callback. class CustomComponent extends React.Component&lt;{}&gt; { private customElement?: HTMLElement | null // customElement is the union type (HTMLElement or null) render() { return React.createElement(&#39;div&#39;, { ref: element =&gt; this.customElement = element // element instanceof Element //=&gt; true // element instanceof HTMLElement //=&gt; true or false } } } Unfortunately, typescript compiler raises an error above: Element is not assignable to HTLMElement. When I started working with DOM elements and DOM types with Typescript I was confused (as a backend dev) since I had considered every Element in the HTML dom tree as an HTMLElement before. I was suprised about the fact that HTMLElement is only the one possible type of Element (in HTML-DOM-TREE). Turned out that Element type has a wider interface scope and if using type-checking tools like Typescript we have to take care of inheritance structure then. That’s why DOM elements are commonly type-guarded or casted (always not recommended since it’s always a code smell) in order to avoid errors that devs don’t understand (including myself before). Anyways, the difference becomes important if you use type checking. What else (apart from HTMLElement) can implement the Element interface? Let’s consider a Node as the basic and generic object that represents everything which appears in a DOM tree. Node is a html tag, comment, an html element. Or let me put that the other way around - every DOM object inherits from Node. &lt;div id=&quot;note&quot;&gt; &lt;!--Who am I?--&gt; &lt;p&gt;Name: Max&lt;/p&gt; &lt;p&gt;Description of myself!&lt;/p&gt; &lt;/div&gt; const element = document.getElementById(&#39;note&#39;); element.toString(); //=&gt; HTMLDivElement const elementList = document.querySelectorAll(&#39;p&#39;); elementList.toString(); //=&gt; NodeList elementList[0].toString(); //=&gt; HTMLParagraphElement const tags = document.getElementsByTagName(&#39;p&#39;); tags.toString(); //=&gt; HTMLCollection, list of HTMLElements tags[0].toString(); //=&gt; HTMLParagraphElement element instanceof Node //=&gt; true element instanceof Element //=&gt; true An Element is a possible incarnation of a Node. So every Element is a Node, but not every Node is an Element. &lt;!--Who am I?--&gt; comment is a Node, but neither an Element nor an HTMLElement. Every node has own type and id (see all node types with its ids). element.nodeType //=&gt; 1 - it&#39;s a Node.ELEMENT_NODE with id 1 element.childNodes //=&gt; NodeList(7) [text, comment, text, p, text, p, text] // lets grab &lt;!--Who am I?--&gt; comment element.childNodes[1].nodeType //=&gt; 8 - it&#39;s a Node.COMMENT_NODE with id 8 element.childNodes[1].nodeType.data //=&gt; &quot;Who am I?&quot; element.childNodes[1] instanceof Element //=&gt; false element.childNodes[1] instanceof Comment //=&gt; true Element and HTMLElement: both are Nodes. Both are Elements, but Element can refer to objects different from HTML universe. And the most surprising for me is i.e to XML DOM element: &lt;!-- note.xml file --&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;note&gt; &lt;name&gt;Name: Max&lt;/name&gt; &lt;description&gt;Description of myself!&lt;/description&gt; &lt;/note&gt; // fetching xml const xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() { if (this.readyState == 4 &amp;&amp; this.status == 200) { // check instances of xml elements showInsanceOfElement(this) } }; xhttp.open(&quot;GET&quot;, &quot;note.xml&quot;, true); xhttp.send(); function showInsanceOfElement(xml) { xmlDoc = xml.responseXML; const [xmlElement] = xmlDoc.getElementsByTagName(&#39;note&#39;); xmlElement instanceof Element //=&gt; true xmlElement instanceof HTMLElement //=&gt; false } And of course Element is the (grand)parent of HTMLElement children (HTMLDivElement, HTMLAnchorElement,HTML-whatever-Element). What is surprising for me - HTMLUnknownElement is an Element too: // create an unknown element const element = document.createElement(&#39;foo&#39;) element instanceof Element //=&gt; true element instanceof HTMLUnknownElement //=&gt; true Summing up - Element could mean everything in a DOM tree and typing a DOM object to Element is not strictness and could cause a type error. That’s why I recommend in code reviews to keep it more strict (eg. as a HTMLElement or XMLElement) as a future-proof.","@type":"BlogPosting","url":"http://localhost:4000/2019/04/28/element-vs-html-element","headline":"Element vs HTMLElement","dateModified":"2019-04-28T00:00:00+02:00","datePublished":"2019-04-28T00:00:00+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/04/28/element-vs-html-element"},"@context":"https://schema.org"}</script><title> Element vs HTMLElement - boch.dev</title><link rel="shortcut icon" href="/favicon.png"><link rel="alternate" type="application/atom+xml" title="boch.dev" href="/atom.xml"><link rel="alternate" type="application/json" title="boch.dev" href="http://localhost:4000/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style> @import url("https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;600&display=swap");*,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:system-ui, sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post{font-family:"Source Sans Pro",sans-serif}.post p{line-height:18pt;margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code,pre{background:#ecedee}.logo{color:red}code{padding:.1rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none;font-family:"Source Sans Pro",sans-serif}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-family:"Source Sans Pro",sans-serif;font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem;margin:2% 0;font-size:11pt}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:0.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{font-family:"Source Sans Pro",sans-serif;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{font-family:"Source Sans Pro",sans-serif;font-weight:400;font-size:13px;color:red;padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:2rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:0.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column;text-align:justify}figcaption{font-size:smaller}.highlight .c,.highlight .cm,.highlight .c1,.highlight .cs{color:#408080}.highlight .k,.highlight .kc,.highlight .kd,.highlight .kn,.highlight .kp,.highlight .kr,.highlight .sx,.highlight .bp,.highlight .nt,.highlight .nb{color:#008000}.highlight .o,.highlight .m,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo,.highlight .il{color:#666666}.highlight .cp{color:#bc7a00}.highlight .gd{color:#a00000}.highlight .gr{color:#ff0000}.highlight .gh,.highlight .gp{color:#000080}.highlight .gi{color:#00a000}.highlight .go{color:#808080}.highlight .gu{color:#800080}.highlight .gt{color:#0040d0}.highlight .kt{color:#b00040}.highlight .na{color:#7d9029}.highlight .no{color:#880000}.highlight .nd,.highlight .ow{color:#aa22ff}.highlight .ni{color:#999999}.highlight .ne{color:#d2413a}.highlight .nc,.highlight .nf,.highlight .nn{color:#0000ff}.highlight .nl{color:#a0a000}.highlight .w{color:#bbbbbb}.highlight .s,.highlight .sb,.highlight .sc,.highlight .sd,.highlight .s2,.highlight .sh,.highlight .s1{color:#ba2121}.highlight .se{color:#bb6622}.highlight .si,.highlight .sr{color:#bb6688}.highlight .ss,.highlight .vs,.highlight .vg,.highlight .vi,.highlight .nv{color:#19177c}.highlight .c,.highlight .cm,.highlight .c1,.highlight .cs,.highlight .ge,.highlight .sd{font-style:italic}.highlight .k,.highlight .kc,.highlight .kd,.highlight .kn,.highlight .kr,.highlight .gh,.highlight .gp,.highlight .gs,.highlight .gu,.highlight .nc,.highlight .ni,.highlight .ne,.highlight .nn,.highlight .nt,.highlight .ow,.highlight .se,.highlight .si{font-weight:bold}</style></head><body><main role="main"><header role="banner"><nav role="navigation"><ul> <img src="https://avatars1.githubusercontent.com/u/42003319?s=460&u=22038b8d46cbc023fbde6b7fc730f6d2ce522826&v=4" style="border-radius: 50%!important;" width="90%"/><li><a href="/" class="logo">boch.dev</a></li><li><a href="/" >Dull posts</a></li><li><a href="/about" >About me</a></li><li><a href="/contact" >Contact info</a></li><li><a href="/atom.xml" >Rss</a></li></ul></nav></header><section class="post"><h2>Element vs HTMLElement</h2><p>Imagine an old React component written in Typescript that renders an element with <code class="highlighter-rouge">React.createElement</code> function from top-level React API with a <code class="highlighter-rouge">ref</code> callback.</p><div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">CustomComponent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span><span class="o">&lt;</span><span class="p">{}</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kr">private</span> <span class="nx">customElement</span><span class="p">?:</span> <span class="nx">HTMLElement</span> <span class="o">|</span> <span class="kc">null</span>
  <span class="c1">// customElement is the union type (HTMLElement or null)</span>
    
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">ref</span><span class="p">:</span> <span class="nx">element</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">customElement</span> <span class="o">=</span> <span class="nx">element</span>
      <span class="c1">// element instanceof Element //=&gt; true</span>
      <span class="c1">// element instanceof HTMLElement //=&gt; true or false </span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>Unfortunately, typescript compiler raises an error above: <em>Element is not assignable to HTLMElement</em>.</p><p>When I started working with DOM elements and DOM types with Typescript I was confused (as a backend dev) since I had considered every Element in the HTML dom tree as an HTMLElement before. I was suprised about the fact that HTMLElement is only the one possible type of Element (in HTML-DOM-TREE).</p><p>Turned out that <code class="highlighter-rouge">Element</code> type has a wider interface scope and if using type-checking tools like Typescript we have to take care of inheritance structure then. That’s why DOM elements are commonly type-guarded or casted (always not recommended since it’s always a code smell) in order to avoid errors that devs don’t understand (including myself before).</p><p>Anyways, the difference becomes important if you use type checking. What else (apart from <code class="highlighter-rouge">HTMLElement</code>) can implement the Element interface?</p><p>Let’s consider a <code class="highlighter-rouge">Node</code> as the basic and generic object that represents everything which appears in a DOM tree. Node is a html tag, comment, an html element. Or let me put that the other way around - every DOM object inherits from Node.</p><div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"note"</span><span class="nt">&gt;</span>
  <span class="c">&lt;!--Who am I?--&gt;</span>
  <span class="nt">&lt;p&gt;</span>Name: Max<span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;p&gt;</span>Description of myself!<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">note</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span> <span class="c1">//=&gt; HTMLDivElement</span>

<span class="kd">const</span> <span class="nx">elementList</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">elementList</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span> <span class="c1">//=&gt; NodeList</span>
<span class="nx">elementList</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">toString</span><span class="p">();</span> <span class="c1">//=&gt; HTMLParagraphElement</span>

<span class="kd">const</span> <span class="nx">tags</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">tags</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span> <span class="c1">//=&gt; HTMLCollection, list of HTMLElements</span>
<span class="nx">tags</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">toString</span><span class="p">();</span> <span class="c1">//=&gt; HTMLParagraphElement</span>

<span class="nx">element</span> <span class="k">instanceof</span> <span class="nx">Node</span> <span class="c1">//=&gt; true </span>
<span class="nx">element</span> <span class="k">instanceof</span> <span class="nx">Element</span> <span class="c1">//=&gt; true</span>
</code></pre></div></div><p>An <code class="highlighter-rouge">Element</code> is a possible incarnation of a Node. So every Element is a Node, but not every Node is an Element. <code class="highlighter-rouge">&lt;!--Who am I?--&gt;</code> comment is a Node, but neither an Element nor an HTMLElement. Every node has own type and id (<a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType#Node_type_constants">see all node types with its ids</a>).</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">element</span><span class="p">.</span><span class="nx">nodeType</span> <span class="c1">//=&gt; 1 - it's a Node.ELEMENT_NODE with id 1</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">childNodes</span> <span class="c1">//=&gt; NodeList(7) [text, comment, text, p, text, p, text]</span>

<span class="c1">// lets grab &lt;!--Who am I?--&gt; comment</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">nodeType</span> <span class="c1">//=&gt; 8 - it's a Node.COMMENT_NODE with id 8</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">nodeType</span><span class="p">.</span><span class="nx">data</span> <span class="c1">//=&gt; "Who am I?"</span>

<span class="nx">element</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">instanceof</span> <span class="nx">Element</span> <span class="c1">//=&gt; false</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">instanceof</span> <span class="nx">Comment</span> <span class="c1">//=&gt; true</span>
</code></pre></div></div><p>Element and HTMLElement: both are Nodes. Both are Elements, but <em>Element can refer to objects different from HTML universe.</em> And the most surprising for me is i.e to XML DOM element:</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- note.xml file --&gt;</span>
<span class="cp">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="nt">&lt;note&gt;</span>
 <span class="nt">&lt;name&gt;</span>Name: Max<span class="nt">&lt;/name&gt;</span>
 <span class="nt">&lt;description&gt;</span>Description of myself!<span class="nt">&lt;/description&gt;</span>
<span class="nt">&lt;/note&gt;</span>
</code></pre></div></div><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// fetching xml </span>
<span class="kd">const</span> <span class="nx">xhttp</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>

<span class="nx">xhttp</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">==</span> <span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// check instances of xml elements</span>
    <span class="nx">showInsanceOfElement</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">xhttp</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="dl">"</span><span class="s2">GET</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">note.xml</span><span class="dl">"</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nx">xhttp</span><span class="p">.</span><span class="nx">send</span><span class="p">();</span>

<span class="kd">function</span> <span class="nx">showInsanceOfElement</span><span class="p">(</span><span class="nx">xml</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">xmlDoc</span> <span class="o">=</span> <span class="nx">xml</span><span class="p">.</span><span class="nx">responseXML</span><span class="p">;</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">xmlElement</span><span class="p">]</span> <span class="o">=</span> <span class="nx">xmlDoc</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="dl">'</span><span class="s1">note</span><span class="dl">'</span><span class="p">);</span>
    
  <span class="nx">xmlElement</span> <span class="k">instanceof</span> <span class="nx">Element</span> <span class="c1">//=&gt; true</span>
  <span class="nx">xmlElement</span> <span class="k">instanceof</span> <span class="nx">HTMLElement</span> <span class="c1">//=&gt; false</span>
<span class="p">}</span>

</code></pre></div></div><p>And of course <code class="highlighter-rouge">Element</code> is the (grand)parent of <code class="highlighter-rouge">HTMLElement</code> children (<code class="highlighter-rouge">HTMLDivElement</code>, <code class="highlighter-rouge">HTMLAnchorElement</code>,<code class="highlighter-rouge">HTML-whatever-Element</code>). What is surprising for me - <code class="highlighter-rouge">HTMLUnknownElement</code> is an Element too:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// create an unknown element</span>
<span class="kd">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">)</span>

<span class="nx">element</span> <span class="k">instanceof</span> <span class="nx">Element</span> <span class="c1">//=&gt; true</span>
<span class="nx">element</span> <span class="k">instanceof</span> <span class="nx">HTMLUnknownElement</span> <span class="c1">//=&gt; true</span>
</code></pre></div></div><p>Summing up - <code class="highlighter-rouge">Element</code> could mean everything in a DOM tree and typing a DOM object to Element is not strictness and could cause a type error. That’s why I recommend in code reviews to keep it more strict (eg. as a <code class="highlighter-rouge">HTMLElement</code> or <code class="highlighter-rouge">XMLElement</code>) as a future-proof.</p><span class="meta"><time datetime="2019-04-28T00:00:00+02:00">April 28, 2019</time> &middot; </span></section></main></body></html>
